# Multithreading: Process vs Thread в Java
## Раздел для Senior Automation / SDET

================================================================================
## 1. PROCESS
================================================================================

ОПРЕДЕЛЕНИЕ
  Process (процесс) — изолированный экземпляр выполняющейся программы.
  Единица выделения ресурсов ОС: своё адресное пространство, файловые дескрипторы,
  учёт ресурсов. Управляется планировщиком ОС.

АРХИТЕКТУРА ПРОЦЕССА (упрощённо для JVM)

    +------------------+
    |     PROCESS      |
    |  (изолирован)    |
    +------------------+
    | Heap              |  <- объекты, общий для потоков процесса
    | Method Area       |  <- классы, статика
    | Thread 1: Stack   |
    | Thread 2: Stack   |
    | ...               |
    +------------------+

  - Heap (куча): объекты, разделяется между потоками внутри процесса.
  - Stack (стек): у каждого потока свой — локальные переменные, вызовы методов.
  - Isolation: один процесс не имеет прямого доступа к памяти другого.

УПРАВЛЕНИЕ ОС
  - Создание: fork/exec (Unix), CreateProcess (Windows).
  - Планирование: процесс — одна из единиц, которым ОС даёт CPU (вместе с потоками).
  - Контекст процесса: отдельное адресное пространство, свои ресурсы.

IPC (Inter-Process Communication) — кратко
  - Сокеты (TCP/UDP), пайпы, очереди сообщений, разделяемая память (mmap).
  - Процессы не делят память — обмен только через явные механизмы ОС/сети.

ПРИМЕР ИЗ ЖИЗНИ
  Chrome, IntelliJ, Telegram — три отдельных процесса.
  Они не читают память друг друга; общение — через сокеты, файлы, буфер обмена и т.д.


================================================================================
## 2. THREAD
================================================================================

ОПРЕДЕЛЕНИЕ
  Thread (поток) — единица выполнения внутри процесса. Один процесс может содержать
  много потоков. Потоки одного процесса делят heap и другие ресурсы процесса.

STACK И HEAP В КОНТЕКСТЕ ПОТОКОВ

    Process
    ├── Heap (ОБЩИЙ для всех потоков)   <- объекты, поля классов
    ├── Method Area
    └── Потоки:
         Thread A: Stack (СВОЙ)         <- локальные переменные, вызовы
         Thread B: Stack (СВОЙ)
         Thread C: Stack (СВОЙ)

  Разделяется:   heap, объекты, статические поля, метод-область.
  Не разделяется: stack каждого потока (локальные переменные, return addresses).

ПОЧЕМУ ВОЗНИКАЮТ RACE CONDITIONS
  Несколько потоков читают/пишут одни и те же данные без синхронизации.
  Результат зависит от порядка выполнения (interleaving) — недетерминизм.

ПРИМЕР НЕАТОМАРНОЙ ОПЕРАЦИИ count++

  count++ на уровне байткода/CPU — три шага:
    1. read   (загрузить значение)
    2. add    (увеличить на 1)
    3. write  (записать обратно)

  Сценарий гонки:
    Thread A: read count=0
    Thread B: read count=0
    Thread A: add, write count=1
    Thread B: add, write count=1
    Итог: 1 вместо 2.

  Вывод: count++ не атомарен. Нужна синхронизация или атомарные типы (AtomicInteger).


================================================================================
## 3. THREAD VS PROCESS — ТАБЛИЦА СРАВНЕНИЯ
================================================================================

+------------------+------------------------+------------------------+
| Критерий         | Process                | Thread                 |
+------------------+------------------------+------------------------+
| Memory           | Своё адресное          | Делит heap процесса    |
|                  | пространство           | Свой stack             |
+------------------+------------------------+------------------------+
| Isolation        | Полная изоляция        | Общая память процесса  |
|                  | от других процессов   | → race conditions      |
+------------------+------------------------+------------------------+
| Creation cost    | Высокий (копирование   | Низкий (стек + запись  |
|                  | адресного пространства)| в структуры ядра)      |
+------------------+------------------------+------------------------+
| Communication    | IPC: сокеты, пайпы,    | Shared memory (общие   |
|                  | очереди, RPC           | объекты в heap)        |
+------------------+------------------------+------------------------+
| Performance      | Переключение контекста| Легче переключение     |
| (context switch) | дороже                 | (в рамках одного процесса)|
+------------------+------------------------+------------------------+


================================================================================
## 4. РЕАЛИЗАЦИЯ В JAVA
================================================================================

--- 4.1 Thread ---

  Класс: java.lang.Thread implements Runnable.

  Наследование от Thread:
    class Worker extends Thread {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName());
        }
    }
    Worker t = new Worker();
    t.start();   // запуск в новом потоке

  Почему start() != run()
    - start() — запрос к JVM/ОС создать новый поток и в нём вызвать run().
    - run() — обычный вызов метода в текущем потоке; новый поток не создаётся.
    На интервью: "Вызов run() вместо start() — выполнение в том же потоке."

  Когда НЕ стоит использовать
    - Один класс может наследовать только один — заняли наследование Thread.
    - Лучше: задача (Runnable/Callable) отдельно от механизма выполнения (Thread/Executor).

--- 4.2 Runnable ---

  Интерфейс: void run(); не возвращает значение, не бросает checked exceptions.

  Почему предпочтительнее
    - Не занимает наследование — класс может наследовать другую иерархию.
    - Разделение: "что делать" (Runnable) и "кто выполняет" (Thread/Executor).
    - Один Runnable можно передать в несколько Thread/Executor.

  Lambda:
    Thread t = new Thread(() -> System.out.println("run"));
    t.start();

--- 4.3 Callable ---

  java.util.concurrent.Callable<V>: V call() throws Exception;

  Отличия от Runnable:
    - Возвращает результат (V).
    - Может бросать checked exceptions.
    - Используется с ExecutorService.submit(), не с new Thread(...).

  Future
    - submit(callable) возвращает Future<V>.
    - get() — блокирует поток до завершения задачи, возвращает результат.
    - get(timeout, unit) — с таймаутом. isDone() — неблокирующая проверка.

  Блокировка future.get()
    - Вызов get() блокирует вызывающий поток до получения результата (или отмены).
    - Для неблокирующей работы: CompletableFuture, callbacks.

  Checked exceptions
    - call() throws Exception — исключения из задачи оборачиваются в ExecutionException
      при вызове future.get().


================================================================================
## 5. THREAD LIFECYCLE
================================================================================

  NEW
    Поток создан (new Thread(...)), start() ещё не вызван.

  RUNNABLE
    После start(). Готов к выполнению или выполняется. ОС планирует его на CPU.

  BLOCKED
    Ожидание монитора (вход в synchronized блок, занятый другим потоком).
    Только при использовании synchronized.

  WAITING
    Ожидание без таймаута: wait(), join() без timeout, LockSupport.park().
    Другой поток должен разбудить: notify/notifyAll, LockSupport.unpark.

  TIMED_WAITING
    Ожидание с таймаутом: Thread.sleep(), wait(timeout), join(timeout),
    LockSupport.parkNanos/parkUntil.

  TERMINATED
    run() завершился или необработанное исключение в run().

  Схема переходов (упрощённо):
    NEW --start()--> RUNNABLE
    RUNNABLE --synchronized lock--> BLOCKED --lock acquired--> RUNNABLE
    RUNNABLE --wait()--> WAITING --notify()--> RUNNABLE
    RUNNABLE --sleep(time)/wait(time)--> TIMED_WAITING --time/notify--> RUNNABLE
    RUNNABLE --run() ends--> TERMINATED


================================================================================
## 6. ПРОБЛЕМЫ МНОГОПОТОЧНОСТИ
================================================================================

  Race condition
    Несколько потоков меняют общее состояние; результат зависит от порядка
    выполнения. Решение: синхронизация, атомарные операции, неизменяемость.

  Deadlock
    Два (или больше) потока ждут друг друга (например, держат по одному lock
    и ждут второй). Решение: единый порядок захвата блокировок, таймауты,
    tryLock, избежание вложенных блокировок.

  Visibility problem
    Изменения переменной в одном потоке не видны другому из-за кэшей CPU
    и переупорядочивания инструкций. Решение: volatile, synchronized,
    happens-before гарантии.

  Атомарность
    Составная операция (read-modify-write) должна выполняться "как одна".
    Решение: synchronized, атомарные классы (AtomicInteger и т.д.).


================================================================================
## 7. СРЕДСТВА СИНХРОНИЗАЦИИ В JAVA
================================================================================

  synchronized
    - Метод или блок: только один поток владеет монитором объекта (или класса).
    - Гарантирует видимость (happens-before при освобождении/захвате).
    - Простой, но грубый — один поток блокирует весь монитор.

  volatile
    - Гарантирует видимость записей/чтений переменной между потоками.
    - Не даёт атомарности для составных операций (например, count++).
    - Подходит для флагов, простых состояний "один пишет — многие читают".

  ReentrantLock
    - Явная блокировка из java.util.concurrent.locks.
    - tryLock(), таймауты, fair lock, несколько Condition.
    - Когда нужен контроль, который synchronized не даёт.

  AtomicInteger (и другие Atomic*)
    - Атомарные операции: incrementAndGet(), compareAndSet(), get().
    - Без блокировок (CAS). Подходят для счётчиков, простых состояний.

  ConcurrentHashMap
    - Потокобезопасная карта без блокировки всей структуры (сегменты/CAS).
    - Итераторы weakly consistent. get/put не блокируют всю карту.


================================================================================
## 8. PRODUCTION-ПОДХОД
================================================================================

  Почему нельзя просто создавать new Thread() на каждую задачу
    - Создание потока дорого (стек, структуры ОС).
    - Нет ограничения числа потоков → исчерпание ресурсов.
    - Нет очереди задач, переиспользования потоков.

  ExecutorService
    - Абстракция пула потоков и очереди задач.
    - submit(Runnable/Callable), execute(Runnable), shutdown(), awaitTermination().

  ThreadPoolExecutor
    - Реализация ExecutorService с настраиваемым числом потоков (core, max),
      очередью задач, политикой отказа. Используется под капотом у
      Executors.newFixedThreadPool, newCachedThreadPool и т.д.

  ForkJoinPool
    - Пул для задач, которые можно рекурсивно дробить (fork) и объединять (join).
    - Work-stealing. Используется в parallel streams, CompletableFuture по умолчанию.

  CompletableFuture
    - Асинхронная цепочка вызовов: thenApply, thenCompose, thenCombine,
      exceptionally, allOf, anyOf. Не блокировать на get() без необходимости.


================================================================================
## 9. ИСПОЛЬЗОВАНИЕ В QA AUTOMATION
================================================================================

  Параллельный запуск тестов
    - Несколько тестов одновременно для ускорения прогона (при отсутствии
      жёстких зависимостей и общих ресурсов).

  TestNG parallel
    - parallel="methods" / "tests" / "classes" — выполнение в нескольких потоках.
    - threadPoolSize, dependsOnMethods — учёт зависимостей и изоляции.

  Selenium Grid
    - Разные узлы (процессы/машины) выполняют тесты параллельно.
    - Потоки и процессы: локально — потоки; распределённо — процессы на разных узлах.

  API async тесты
    - Асинхронные клиенты (WebClient, async HTTP) — не блокировать поток.
    - Проверка таймаутов, порядка ответов, callback'ов.


================================================================================
## ТИПИЧНЫЕ ВОПРОСЫ НА ИНТЕРВЬЮ
================================================================================

  - В чём разница между процессом и потоком?
    Процесс — изолированная единица с собственным адресным пространством.
    Поток — единица выполнения внутри процесса; делит heap процесса, имеет свой stack.

  - Что будет, если вызвать run() вместо start()?
    Код run() выполнится в текущем потоке; новый поток не создаётся.

  - Почему Runnable лучше наследования от Thread?
    Не занимает наследование; разделение задачи и механизма выполнения.

  - Чем Callable отличается от Runnable?
    Возвращает результат (Future), может бросать checked exceptions.

  - Почему count++ не потокобезопасен?
    Не атомарен: read-modify-write; возможна гонка. Нужен synchronized или AtomicInteger.

  - Что такое deadlock? Как избежать?
    Взаимное ожидание блокировок. Избегать: единый порядок захвата, таймауты, tryLock.

  - Зачем в production используют ExecutorService, а не new Thread()?
    Пул потоков, очередь задач, ограничение ресурсов, переиспользование потоков.

  - Что делает volatile?
    Гарантирует видимость изменений между потоками; не даёт атомарности для составных операций.


================================================================================
## РЕЗЮМЕ ДЛЯ ЗАПОМИНАНИЯ
================================================================================

  Process: изолированная программа, своя память, управляется ОС, общение через IPC.
  Thread: поток внутри процесса; общий heap, свой stack; гонки при общем состоянии.

  Java: Thread (start vs run), Runnable (предпочтительно), Callable + Future.
  Синхронизация: synchronized, volatile, ReentrantLock, Atomic*, ConcurrentHashMap.

  Production: ExecutorService, пулы потоков, CompletableFuture — не плодить Thread вручную.
  QA: параллельные тесты (TestNG), Grid, асинхронные API-проверки.

  Жизненный цикл: NEW → RUNNABLE → BLOCKED/WAITING/TIMED_WAITING → TERMINATED.
